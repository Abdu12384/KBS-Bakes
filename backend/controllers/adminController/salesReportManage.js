
const PDFDocument = require('pdfkit');
const Order = require('../../model/orderModel');
const exceljs = require('exceljs');



const generatePDFReport = async (req, res) => {
  try {
    const { timeFilter, sortBy = 'orderDate', sortOrder = -1 } = req.query;
    

    const dateFilter = {};
    const now = new Date();
    let startDate = new Date();
    let dateRangeText = 'All Time';
    
    if (timeFilter !== 'All Time') {
      switch (timeFilter) {
        case 'Daily':
          startDate.setHours(0, 0, 0, 0);
          dateRangeText = startDate.toLocaleDateString();
          break;
        case 'Weekly':
          startDate.setDate(now.getDate() - now.getDay());
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
        case 'Monthly':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
      }
      dateFilter.orderDate = { $gte: startDate };
    }


    const orders = await Order.find(dateFilter)
      .sort({ [sortBy]: parseInt(sortOrder) })
      .populate('userId')
      .populate('products.productId');


    const summary = {
      totalOrders: orders.length,
      totalRevenue: orders.reduce((sum, order) => sum + order.totalPrice, 0),
      totalDiscount: orders.reduce((sum, order) => sum + (order.discount || 0), 0),
      averageOrderValue: orders.length > 0 ? 
        orders.reduce((sum, order) => sum + order.totalPrice, 0) / orders.length : 0
    };


    const doc = new PDFDocument({
      size: 'A4',
      margin: 50,
      bufferPages: true 
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', 'attachment; filename=sales-report.pdf');
    doc.pipe(res);

    // Helper function for consistent styling
    const styles = {
      title: { font: 'Helvetica-Bold', size: 25 },
      subtitle: { font: 'Helvetica', size: 12 },
      heading: { font: 'Helvetica-Bold', size: 14 },
      tableHeader: { font: 'Helvetica-Bold', size: 10 },
      tableCell: { font: 'Helvetica', size: 10 },
      footer: { font: 'Helvetica', size: 8 }
    };

    const setStyle = (style) => {
      doc.font(style.font).fontSize(style.size);
    };


    const addHeader = () => {


      // Add decorative line
      doc.lineWidth(2)
         .moveTo(50, 40)
         .lineTo(545, 40)
         .stroke('#2196F3');

      setStyle(styles.title);
      doc.text('Sales Report', 50, 60);
      
      setStyle(styles.subtitle);
      doc.text(`Generated on: ${new Date().toLocaleString()}`, 50, 90);
      doc.text(`Date Range: ${dateRangeText}`, 50, 110);

      // Add another decorative line
      doc.lineWidth(1)
         .moveTo(50, 130)
         .lineTo(545, 130)
         .stroke('#E0E0E0');
    };

    // Add footer with page numbers
    const addFooter = () => {
      const pages = doc.bufferedPageRange();
      for (let i = 0; i < pages.count; i++) {
        doc.switchToPage(i);
        setStyle(styles.footer);
        
        // Add footer text
        doc.text(
          'Generated by Your Company Name',
          50,
          doc.page.height - 50,
          { align: 'left' }
        );
        
        // Add page number
        doc.text(
          `Page ${i + 1} of ${pages.count}`,
          doc.page.width - 150,
          doc.page.height - 50,
          { align: 'right' }
        );
      }
    };

    // Start adding content
    addHeader();

    // Add summary section with styled boxes
    setStyle(styles.heading);
    doc.text('Summary', 50, 150);

    // Create summary boxes
    const boxWidth = 120;
    const boxHeight = 60;
    const boxSpacing = 15;
    const boxes = [
      { label: 'Total Orders', value: summary.totalOrders.toString() },
      { label: 'Total Revenue', value: `₹${summary.totalRevenue.toFixed(2)}` },
      { label: 'Total Discount', value: `₹${summary.totalDiscount.toFixed(2)}` },
      { label: 'Avg. Order Value', value: `₹${summary.averageOrderValue.toFixed(2)}` }
    ];

    boxes.forEach((box, index) => {
      const x = 50 + (index * (boxWidth + boxSpacing));
      const y = 170;


      doc.rect(x, y, boxWidth, boxHeight)
         .fill('#F5F5F5');


      setStyle(styles.tableHeader);
      doc.fill('#666666')
         .text(box.label, x + 10, y + 15, { width: boxWidth - 20, align: 'center' });


      setStyle(styles.tableCell);
      doc.fill('#000000')
         .text(box.value, x + 10, y + 35, { width: boxWidth - 20, align: 'center' });
    });


    doc.addPage();
    addHeader(); 

    setStyle(styles.heading);
    doc.text('Order Details', 50, 150);

    const orderTable = {
      headers: ['Order ID', 'Product', 'Quantity', 'Date', 'Customer', 'Total'],
      rows: orders.map(order => [
        order._id.toString().slice(-6),
        order.products[0]?.productId?.productName || '',
        order.products[0]?.quantity.toString() || '',
        new Date(order.orderDate).toLocaleDateString(),
        order.userId?.fullName || '',
        `₹${order.totalPrice.toLocaleString()}`
      ])
    };

    // Enhanced table creation with alternating row colors
    const createTable = (doc, table, startY) => {
      const columnCount = table.headers.length;
      const columnWidth = (doc.page.width - 100) / columnCount;
      let yPos = startY;

      // Draw headers with background
      doc.rect(50, yPos, doc.page.width - 100, 20)
         .fill('#2196F3');

      setStyle(styles.tableHeader);
      doc.fill('#FFFFFF');
      table.headers.forEach((header, i) => {
        doc.text(header, 50 + (i * columnWidth), yPos + 5, {
          width: columnWidth,
          align: 'left'
        });
      });


      setStyle(styles.tableCell);
      table.rows.forEach((row, rowIndex) => {
        yPos += 25;


        if (yPos > doc.page.height - 75) {
          doc.addPage();
          addHeader();
          yPos = 150;


          doc.rect(50, yPos, doc.page.width - 100, 20)
             .fill('#2196F3');

          setStyle(styles.tableHeader);
          doc.fill('#FFFFFF');
          table.headers.forEach((header, i) => {
            doc.text(header, 50 + (i * columnWidth), yPos + 5, {
              width: columnWidth,
              align: 'left'
            });
          });
          yPos += 25;
          setStyle(styles.tableCell);
        }

        // Draw alternating row background
        if (rowIndex % 2 === 0) {
          doc.rect(50, yPos - 5, doc.page.width - 100, 20)
             .fill('#F5F5F5');
        }

        doc.fill('#000000');
        row.forEach((cell, i) => {
          doc.text(cell, 50 + (i * columnWidth), yPos, {
            width: columnWidth,
            align: 'left'
          });
        });
      });

      return yPos;
    };

    createTable(doc, orderTable, 180);

    // Add footer to all pages
    addFooter();

    // Finalize the PDF
    doc.end();
  } catch (error) {
    console.error('PDF generation error:', error);
    res.status(500).json({ error: 'Failed to generate PDF report' });
  }
};







const salesData =  async (req, res) => {
    try {
      console.log(req.query);
      
        const { 
            timeFilter, 
            sortBy = 'orderDate', 
            sortOrder = -1,
            page = 1,
            limit = 10
        } = req.query;

        const dateFilter = {};
        const now = new Date();

        if (timeFilter !== 'All Time') {
            let startDate = new Date();
            switch (timeFilter) {
                case 'Daily':
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case 'Weekly':
                    startDate.setDate(now.getDate() - now.getDay());
                    break;
                case 'Monthly':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
            }
            dateFilter.orderDate = { $gte: startDate };
        }

        const sortConfig = {};
        sortConfig[sortBy] = parseInt(sortOrder);

        const skip = (page - 1) * limit;

        const orders = await Order.find(dateFilter)
            .sort(sortConfig)
            .skip(skip)
            .limit(parseInt(limit))
            .populate('userId')
            .populate('products.productId');

         const summury = await Order.find()   
            const OrderSummury = {
              totalOrders: summury.length,
              totalRevenue: summury.reduce((sum, order) => sum + order.totalPrice, 0),
              totalDiscount: summury.reduce((sum, order) => sum + (order.discount || 0), 0),
              timeRange: timeFilter,
              sortedBy: sortBy,
              sortOrder: sortOrder === 1 ? 'ascending' : 'descending'
          };
        const total = await Order.countDocuments(dateFilter);
        console.log(orders);


    console.log('change',OrderSummury);
    

        res.json({
            orders,
            pagination: {
                total,
                pages: Math.ceil(total / limit),
                currentPage: parseInt(page),
                limit: parseInt(limit)
            },
            OrderSummury 
        });

    } catch (error) {
        console.error('Error fetching sales data:', error);
        res.status(500).json({ error: 'Failed to fetch sales data' });
    }
}



const generateExcelReport = async (req, res) => {
  try {
    const { timeFilter, sortBy = 'orderDate', sortOrder = -1 } = req.query;
    


    const dateFilter = {};
    const now = new Date();
    let startDate = new Date();
    
    if (timeFilter !== 'All Time') {
      switch (timeFilter) {
        case 'Daily':
          startDate.setHours(0, 0, 0, 0);
          dateRangeText = startDate.toLocaleDateString();
          break;
        case 'Weekly':
          startDate.setDate(now.getDate() - now.getDay());
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
        case 'Monthly':
          startDate = new Date(now.getFullYear(), now.getMonth(), 1);
          dateRangeText = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
          break;
      }
      dateFilter.orderDate = { $gte: startDate };
    }
    const orders = await Order.find(dateFilter)
      .sort({ [sortBy]: parseInt(sortOrder) })
      .populate('userId')
      .populate('products.productId');

    // Calculate summary
    const summary = {
      totalOrders: orders.length,
      totalRevenue: orders.reduce((sum, order) => sum + order.totalPrice, 0),
      totalDiscount: orders.reduce((sum, order) => sum + (order.discount || 0), 0),
      averageOrderValue: orders.length > 0 ? 
        orders.reduce((sum, order) => sum + order.totalPrice, 0) / orders.length : 0
    };

    // Create Excel workbook
    const workbook = new exceljs.Workbook();
    workbook.creator = 'Your Company Name';
    workbook.created = new Date();

    // Add Summary worksheet
    const summarySheet = workbook.addWorksheet('Summary');
    summarySheet.columns = [
      { header: 'Metric', key: 'metric', width: 20 },
      { header: 'Value', key: 'value', width: 20 }
    ];

    // Style the header
    summarySheet.getRow(1).font = { bold: true };
    summarySheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF2C3E50' }
    };
    summarySheet.getRow(1).font = { bold: true, color: { argb: 'FFFFFFFF' } };

    // Add summary data
    summarySheet.addRows([
      { metric: 'Total Orders', value: summary.totalOrders },
      { metric: 'Total Revenue', value: `₹${summary.totalRevenue.toFixed(2)}` },
      { metric: 'Total Discount', value: `₹${summary.totalDiscount.toFixed(2)}` },
      { metric: 'Average Order Value', value: `₹${summary.averageOrderValue.toFixed(2)}` }
    ]);

    // Add Orders worksheet
    const ordersSheet = workbook.addWorksheet('Order Details');
    ordersSheet.columns = [
      { header: 'Order ID', key: 'orderId', width: 15 },
      { header: 'Product', key: 'product', width: 30 },
      { header: 'Quantity', key: 'quantity', width: 10 },
      { header: 'Date', key: 'date', width: 15 },
      { header: 'Customer', key: 'customer', width: 20 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Discount', key: 'discount', width: 15 },
      { header: 'Total', key: 'total', width: 15 }
    ];

    // Style the header
    ordersSheet.getRow(1).font = { bold: true };
    ordersSheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FF2C3E50' }
    };
    ordersSheet.getRow(1).font = { bold: true, color: { argb: 'FFFFFFFF' } };

    // Add order data
    orders.forEach(order => {
      ordersSheet.addRow({
        orderId: order._id.toString().slice(-6),
        product: order.products[0]?.productId?.productName || '',
        quantity: order.products[0]?.quantity || '',
        date: new Date(order.orderDate).toLocaleDateString(),
        customer: order.userId?.fullName || '',
        status: order.status,
        discount: order.discount ? `₹${order.discount.toFixed(2)}` : 'No Discount',
        total: `₹${order.totalPrice.toFixed(2)}`
      });
    });

    // Add some style to the data
    ordersSheet.eachRow((row, rowNumber) => {
      row.eachCell((cell) => {
        cell.border = {
          top: { style: 'thin' },
          left: { style: 'thin' },
          bottom: { style: 'thin' },
          right: { style: 'thin' }
        };
      });
      
      if (rowNumber % 2 === 0) {
        row.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: 'FFF8FAFC' }
        };
      }
    });

    // Set response headers
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=sales-report.xlsx');

    // Write to response
    await workbook.xlsx.write(res);
    res.end();
  } catch (error) {
    console.error('Excel generation error:', error);
    res.status(500).json({ error: 'Failed to generate Excel report' });
  }
};





module.exports={
  generatePDFReport,
  generateExcelReport,
  salesData
}